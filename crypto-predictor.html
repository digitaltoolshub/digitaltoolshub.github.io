<!DOCTYPE html>
<html lang="en">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-R4N9RB1SNN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-R4N9RB1SNN');
    </script>

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3518482809806042"
        crossorigin="anonymous"></script>

    <script id="Cookiebot" src="https://consent.cookiebot.com/uc.js" data-cbid="b84b76df-2fc0-4c4c-856d-b4b09a8e3c7f"
        type="text/javascript" async></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoPredictor | AI-Powered Cryptocurrency Price Predictions</title>
    <meta name="title" content="CryptoPredictor | AI-Powered Cryptocurrency Price Predictions">
    <meta name="description"
        content="Free real-time cryptocurrency price predictions using AI (LSTM & ARIMA). Analyze market trends for Bitcoin, Ethereum, and more.">
    <meta name="keywords"
        content="crypto prediction ai, bitcoin price prediction, ethereum forecast, lstm crypto trading, arima crypto model, ai crypto tool, cryptocurrency analysis, digital tools hub">
    <meta name="author" content="Digital Tools Hub">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://digitaltoolshub.github.io/crypto-predictor.html">
    <meta property="og:title" content="CryptoPredictor | AI-Powered Cryptocurrency Price Predictions">
    <meta property="og:description"
        content="Free real-time cryptocurrency price predictions using AI (LSTM & ARIMA). Analyze market trends for Bitcoin, Ethereum, and more.">
    <meta property="og:image" content="https://digitaltoolshub.github.io/preview.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://digitaltoolshub.github.io/crypto-predictor.html">
    <meta property="twitter:title" content="CryptoPredictor | AI-Powered Cryptocurrency Price Predictions">
    <meta property="twitter:description"
        content="Free real-time cryptocurrency price predictions using AI (LSTM & ARIMA). Analyze market trends for Bitcoin, Ethereum, and more.">
    <meta property="twitter:image" content="https://digitaltoolshub.github.io/preview.png">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://digitaltoolshub.github.io/crypto-predictor.html">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />

    <link rel="preconnect" href="https://api.coingecko.com">
    <link rel="preconnect" href="https://api.binance.com">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/arima@1.0.0/arima.min.js"></script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
        }

        body {
            font-family: 'Segoe UI', system-ui;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: var(--light);
            color: var(--dark);
        }

        header {
            background: var(--primary);
            color: white;
            padding: 1.5rem;
            text-align: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            gap: 2rem;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .chart-container {
            position: relative;
            min-height: 400px;
        }

        .model-controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
        }

        button,
        select,
        input {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        button {
            background: var(--secondary);
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #2980b9;
        }

        button.secondary {
            background: var(--accent);
        }

        .prediction-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 0.5rem;
        }

        .up {
            background: #2ecc71;
            color: white;
        }

        .down {
            background: #e74c3c;
            color: white;
        }

        footer {
            background: var(--primary);
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 2rem;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>CryptoPredictor <span style="font-size: 0.8em;">üöÄ</span></h1>
        <p>AI-Powered Cryptocurrency Predictions with LSTM & ARIMA Models</p>
    </header>

    <div class="container">
        <div class="card">
            <h2>Real-Time Market Data</h2>
            <div id="marketData"></div>
            <div class="model-controls">
                <select id="coinSelect">
                    <option value="bitcoin">Bitcoin</option>
                    <option value="ethereum">Ethereum</option>
                    <option value="binancecoin">BNB</option>
                </select>
                <button id="refreshData">Refresh Data</button>
            </div>
        </div>

        <div class="card">
            <h2>Price Analysis</h2>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
            <div class="model-controls">
                <select id="timeframe">
                    <option value="7">7 Days</option>
                    <option value="14">14 Days</option>
                    <option value="30" selected>30 Days</option>
                </select>
                <button id="runLSTM">Run LSTM</button>
                <button id="runARIMA" class="secondary">Run ARIMA</button>
            </div>
        </div>

        <div class="card">
            <h2>AI Predictions</h2>
            <div id="predictions">
                <div id="lstmPrediction">
                    <h3>LSTM Neural Network</h3>
                    <p>Loading model...</p>
                </div>
                <div id="arimaPrediction">
                    <h3>ARIMA Model</h3>
                    <p>Waiting for data...</p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Technical Indicators</h2>
            <div id="indicators">
                <p>RSI: <span id="rsiValue">-</span></p>
                <p>MACD: <span id="macdValue">-</span></p>
                <p>Bollinger Bands: <span id="bollingerValue">-</span></p>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="card">
            <h2>Set Price Alert</h2>
            <form id="alertForm">
                <div style="margin-bottom: 1rem;">
                    <input type="number" id="alertPrice" step="0.01" placeholder="Target price" style="width: 100%;">
                </div>
                <button type="submit">Set Alert</button>
            </form>
            <div id="alertsList" style="margin-top: 1rem;"></div>
        </div>

        <div class="card">
            <h2>Portfolio Tracker</h2>
            <form id="portfolioForm">
                <div style="display: grid; gap: 1rem; margin-bottom: 1rem;">
                    <input type="text" id="coinId" placeholder="Coin ID (e.g., bitcoin)">
                    <input type="number" id="amount" step="0.0001" placeholder="Amount">
                </div>
                <button type="submit">Add to Portfolio</button>
            </form>
            <div id="portfolioValue" style="margin-top: 1rem;"></div>
        </div>
    </div>

    <footer>
        <p>Data provided by CoinGecko Public API | Predictions powered by TensorFlow.js</p>
        <p>¬© 2023 CryptoPredictor. Free to use. Not financial advice.</p>
    </footer>

    <script>
        // ==================== SEO Structured Data ====================
        document.addEventListener('DOMContentLoaded', () => {
            const structuredData = {
                "@context": "https://schema.org",
                "@type": "WebApplication",
                "name": "CryptoPredictor",
                "description": "AI-powered cryptocurrency price predictions using LSTM neural networks and ARIMA models",
                "applicationCategory": "FinancialApplication",
                "operatingSystem": "Web browser",
                "offers": {
                    "@type": "Offer",
                    "price": "0",
                    "priceCurrency": "USD"
                }
            };
            const script = document.createElement('script');
            script.type = "application/ld+json";
            script.text = JSON.stringify(structuredData);
            document.head.appendChild(script);
        });

        // ==================== Global Variables ====================
        let priceChart;
        let historicalData = [];
        let lstmModel;
        let arimaModel;
        const alerts = JSON.parse(localStorage.getItem('cryptoAlerts') || '[]');
        const portfolio = JSON.parse(localStorage.getItem('cryptoPortfolio') || '{}');

        // ==================== Main Data Fetching ====================
        async function fetchMarketData() {
            try {
                showLoading(true);
                const coin = document.getElementById('coinSelect').value;
                const days = document.getElementById('timeframe').value;

                // Fetch data from CoinGecko
                const [marketResponse, historyResponse] = await Promise.all([
                    fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coin}&order=market_cap_desc`),
                    fetch(`https://api.coingecko.com/api/v3/coins/${coin}/market_chart?vs_currency=usd&days=${days}&interval=daily`)
                ]);

                const [marketData, historyData] = await Promise.all([
                    marketResponse.json(),
                    historyResponse.json()
                ]);

                historicalData = historyData.prices.map(item => ({
                    date: new Date(item[0]),
                    price: item[1]
                }));

                updateMarketOverview(marketData);
                updateChart();
                calculateIndicators();
                checkAlerts(marketData);
                updatePortfolioDisplay();

            } catch (error) {
                console.error('Error fetching data:', error);
                alert('Failed to fetch market data. Please try again later.');
            } finally {
                showLoading(false);
            }
        }

        // ==================== Chart Functions ====================
        function updateChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            if (priceChart) priceChart.destroy();

            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: historicalData.map(item => item.date.toLocaleDateString()),
                    datasets: [{
                        label: 'Price (USD)',
                        data: historicalData.map(item => item.price),
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        // ==================== AI Prediction Models ====================

        // LSTM Model
        async function setupLSTM() {
            lstmModel = tf.sequential();
            lstmModel.add(tf.layers.lstm({
                units: 32,
                inputShape: [10, 1],
                returnSequences: false
            }));
            lstmModel.add(tf.layers.dense({ units: 1 }));

            lstmModel.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'meanSquaredError'
            });
        }

        async function runLSTMPrediction() {
            try {
                showLoading(true, 'lstm');
                document.getElementById('lstmPrediction').innerHTML = '<h3>LSTM Neural Network</h3><p>Training model...</p>';

                if (!lstmModel) await setupLSTM();

                // Prepare data
                const prices = historicalData.map(item => item.price);
                const normalizedData = normalizeData(prices);
                const [trainX, trainY] = createDataset(normalizedData, 10);

                // Train model
                await lstmModel.fit(trainX, trainY, {
                    epochs: 50,
                    batchSize: 32,
                    verbose: 0
                });

                // Predict next 5 days
                const lastWindow = normalizedData.slice(-10);
                const predictions = [];

                for (let i = 0; i < 5; i++) {
                    const input = tf.tensor2d([lastWindow], [1, 10, 1]);
                    const pred = lstmModel.predict(input).dataSync()[0];
                    predictions.push(pred);
                    lastWindow.shift();
                    lastWindow.push(pred);
                }

                // Denormalize predictions
                const denormPredictions = denormalizeData(predictions, Math.min(...prices), Math.max(...prices));
                const currentPrice = prices[prices.length - 1];
                const predictedPrice = denormPredictions[denormPredictions.length - 1];
                const changePercent = ((predictedPrice - currentPrice) / currentPrice) * 100;

                // Display results
                const direction = changePercent >= 0 ? 'up' : 'down';
                const badgeClass = direction === 'up' ? 'up' : 'down';
                const arrow = direction === 'up' ? '‚Üë' : '‚Üì';

                document.getElementById('lstmPrediction').innerHTML = `
            <h3>LSTM Neural Network</h3>
            <p>Next 5 days prediction: ${denormPredictions.map(p => '$' + p.toFixed(2)).join(' ‚Üí ')}</p>
            <p>Predicted price: $${predictedPrice.toFixed(2)} 
                <span class="prediction-badge ${badgeClass}">${arrow} ${Math.abs(changePercent).toFixed(2)}%</span>
            </p>
        `;

            } catch (error) {
                console.error('LSTM error:', error);
                document.getElementById('lstmPrediction').innerHTML = '<h3>LSTM Neural Network</h3><p>Error generating prediction</p>';
            } finally {
                showLoading(false, 'lstm');
            }
        }

        // ARIMA Model
        async function runARIMAPrediction() {
            try {
                showLoading(true, 'arima');
                document.getElementById('arimaPrediction').innerHTML = '<h3>ARIMA Model</h3><p>Calculating...</p>';

                const prices = historicalData.map(item => item.price);

                // Initialize ARIMA model
                const model = new ARIMA({
                    p: 2,  // AR order
                    d: 1,  // Differencing order
                    q: 2,  // MA order
                    verbose: false
                }).train(prices);

                // Predict next 5 values
                const [predictedValues] = model.predict(5);
                const currentPrice = prices[prices.length - 1];
                const predictedPrice = predictedValues[predictedValues.length - 1];
                const changePercent = ((predictedPrice - currentPrice) / currentPrice) * 100;

                // Display results
                const direction = changePercent >= 0 ? 'up' : 'down';
                const badgeClass = direction === 'up' ? 'up' : 'down';
                const arrow = direction === 'up' ? '‚Üë' : '‚Üì';

                document.getElementById('arimaPrediction').innerHTML = `
            <h3>ARIMA Model</h3>
            <p>Next 5 days prediction: ${predictedValues.map(p => '$' + p.toFixed(2)).join(' ‚Üí ')}</p>
            <p>Predicted price: $${predictedPrice.toFixed(2)} 
                <span class="prediction-badge ${badgeClass}">${arrow} ${Math.abs(changePercent).toFixed(2)}%</span>
            </p>
        `;

            } catch (error) {
                console.error('ARIMA error:', error);
                document.getElementById('arimaPrediction').innerHTML = '<h3>ARIMA Model</h3><p>Error generating prediction</p>';
            } finally {
                showLoading(false, 'arima');
            }
        }

        // Helper functions for LSTM
        function normalizeData(data) {
            const min = Math.min(...data);
            const max = Math.max(...data);
            return data.map(x => (x - min) / (max - min));
        }

        function denormalizeData(data, min, max) {
            return data.map(x => x * (max - min) + min);
        }

        function createDataset(data, windowSize) {
            const X = [];
            const Y = [];

            for (let i = 0; i < data.length - windowSize; i++) {
                X.push(data.slice(i, i + windowSize));
                Y.push(data[i + windowSize]);
            }

            return [
                tf.tensor3d(X, [X.length, windowSize, 1]),
                tf.tensor2d(Y, [Y.length, 1])
            ];
        }

        // ==================== Technical Indicators ====================
        function calculateIndicators() {
            if (historicalData.length < 14) return;

            const prices = historicalData.map(item => item.price);

            // Calculate RSI
            const rsi = calculateRSI(prices, 14);
            document.getElementById('rsiValue').textContent = rsi.toFixed(2);

            // Calculate MACD
            const macd = calculateMACD(prices);
            document.getElementById('macdValue').textContent = `MACD: ${macd.macd.toFixed(2)}, Signal: ${macd.signal.toFixed(2)}`;

            // Calculate Bollinger Bands
            const bb = calculateBollingerBands(prices, 20);
            document.getElementById('bollingerValue').textContent =
                `Upper: $${bb.upper.toFixed(2)}, Middle: $${bb.middle.toFixed(2)}, Lower: $${bb.lower.toFixed(2)}`;
        }

        function calculateRSI(prices, period = 14) {
            let gains = 0;
            let losses = 0;

            for (let i = 1; i <= period; i++) {
                const change = prices[i] - prices[i - 1];
                if (change >= 0) gains += change;
                else losses -= change;
            }

            const avgGain = gains / period;
            const avgLoss = losses / period;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const fastEMA = calculateEMA(prices, fastPeriod);
            const slowEMA = calculateEMA(prices, slowPeriod);
            const macdLine = fastEMA.map((val, idx) => val - slowEMA[idx]);
            const signalLine = calculateEMA(macdLine, signalPeriod);

            return {
                macd: macdLine[macdLine.length - 1],
                signal: signalLine[signalLine.length - 1]
            };
        }

        function calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            const ema = [prices.slice(0, period).reduce((a, b) => a + b) / period];

            for (let i = period; i < prices.length; i++) {
                ema.push(prices[i] * k + ema[ema.length - 1] * (1 - k));
            }

            return ema;
        }

        function calculateBollingerBands(prices, period = 20, multiplier = 2) {
            const middleBand = calculateSMA(prices, period);
            const stdDev = calculateStandardDeviation(prices, period);

            return {
                upper: middleBand[middleBand.length - 1] + (stdDev[stdDev.length - 1] * multiplier),
                middle: middleBand[middleBand.length - 1],
                lower: middleBand[middleBand.length - 1] - (stdDev[stdDev.length - 1] * multiplier)
            };
        }

        function calculateSMA(prices, period) {
            const sma = [];
            for (let i = period - 1; i < prices.length; i++) {
                const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                sma.push(sum / period);
            }
            return sma;
        }

        function calculateStandardDeviation(prices, period) {
            const deviations = [];
            const sma = calculateSMA(prices, period);

            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const mean = sma[i - period + 1];
                const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
                deviations.push(Math.sqrt(variance));
            }

            return deviations;
        }

        // ==================== Alert System ====================
        document.getElementById('alertForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const coin = document.getElementById('coinSelect').value;
            const price = parseFloat(document.getElementById('alertPrice').value);

            if (!price || isNaN(price)) {
                alert('Please enter a valid price');
                return;
            }

            const newAlert = {
                coin,
                price,
                triggered: false
            };

            alerts.push(newAlert);
            localStorage.setItem('cryptoAlerts', JSON.stringify(alerts));
            updateAlertsList();
            document.getElementById('alertForm').reset();
        });

        function checkAlerts(marketData) {
            const coin = document.getElementById('coinSelect').value;
            const currentCoin = marketData.find(c => c.id === coin);
            if (!currentCoin) return;

            const currentPrice = currentCoin.current_price;

            alerts.forEach((alert, index) => {
                if (alert.coin === coin && !alert.triggered) {
                    if ((alert.price >= currentPrice && alert.direction === 'below') ||
                        (alert.price <= currentPrice && (!alert.direction || alert.direction === 'above'))) {

                        alert.triggered = true;
                        alerts[index] = alert;
                        localStorage.setItem('cryptoAlerts', JSON.stringify(alerts));

                        // Show browser notification
                        if (Notification.permission === 'granted') {
                            new Notification(`Price alert triggered for ${coin}`, {
                                body: `Price is now $${currentPrice.toFixed(2)} (target: $${alert.price.toFixed(2)})`,
                                icon: 'https://cryptopredictor.com/icon.png'
                            });
                        } else if (Notification.permission !== 'denied') {
                            Notification.requestPermission().then(permission => {
                                if (permission === 'granted') {
                                    new Notification(`Price alert triggered for ${coin}`, {
                                        body: `Price is now $${currentPrice.toFixed(2)} (target: $${alert.price.toFixed(2)})`,
                                        icon: 'https://cryptopredictor.com/icon.png'
                                    });
                                }
                            });
                        }
                    }
                }
            });

            updateAlertsList();
        }

        function updateAlertsList() {
            const coin = document.getElementById('coinSelect').value;
            const filteredAlerts = alerts.filter(alert => alert.coin === coin);

            document.getElementById('alertsList').innerHTML = filteredAlerts.length > 0 ?
                filteredAlerts.map(alert => `
            <div style="padding: 0.5rem; margin: 0.3rem 0; background: ${alert.triggered ? '#f8d7da' : '#e2e3e5'}; 
                border-radius: 5px; display: flex; justify-content: space-between;">
                <span>${alert.coin} @ $${alert.price.toFixed(2)}</span>
                <span>${alert.triggered ? '‚úÖ Triggered' : '‚è± Active'}</span>
            </div>
        `).join('') :
                '<p>No alerts set for this coin</p>';
        }

        // ==================== Portfolio Management ====================
        document.getElementById('portfolioForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const coin = document.getElementById('coinId').value.toLowerCase();
            const amount = parseFloat(document.getElementById('amount').value);

            if (!coin || !amount || isNaN(amount)) {
                alert('Please enter valid coin and amount');
                return;
            }

            portfolio[coin] = (portfolio[coin] || 0) + amount;
            localStorage.setItem('cryptoPortfolio', JSON.stringify(portfolio));
            updatePortfolioDisplay();
            document.getElementById('portfolioForm').reset();
        });

        async function updatePortfolioDisplay() {
            if (Object.keys(portfolio).length === 0) {
                document.getElementById('portfolioValue').innerHTML = '<p>Your portfolio is empty</p>';
                return;
            }

            try {
                // Get current prices for all coins in portfolio
                const coinIds = Object.keys(portfolio).join(',');
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinIds}`);
                const marketData = await response.json();

                let totalValue = 0;
                let portfolioHTML = '<div style="display: grid; gap: 0.5rem;">';

                marketData.forEach(coin => {
                    const amount = portfolio[coin.id];
                    const value = amount * coin.current_price;
                    totalValue += value;

                    portfolioHTML += `
                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid #eee;">
                    <span>${coin.name} (${coin.symbol.toUpperCase()})</span>
                    <span>${amount.toFixed(4)} √ó $${coin.current_price.toFixed(2)} = $${value.toFixed(2)}</span>
                </div>
            `;
                });

                portfolioHTML += `
            <div style="font-weight: bold; padding: 0.5rem 0; margin-top: 0.5rem; border-top: 1px solid #ddd;">
                <span>Total Portfolio Value:</span>
                <span>$${totalValue.toFixed(2)}</span>
            </div>
        </div>`;

                document.getElementById('portfolioValue').innerHTML = portfolioHTML;

            } catch (error) {
                console.error('Error updating portfolio:', error);
                document.getElementById('portfolioValue').innerHTML = '<p>Error loading portfolio data</p>';
            }
        }

        // ==================== UI Helpers ====================
        function showLoading(show, element = 'global') {
            if (element === 'global') {
                document.getElementById('refreshData').disabled = show;
                document.getElementById('runLSTM').disabled = show;
                document.getElementById('runARIMA').disabled = show;
            }

            // Can add more specific loading indicators here
        }

        // ==================== Event Listeners ====================
        document.getElementById('refreshData').addEventListener('click', fetchMarketData);
        document.getElementById('runLSTM').addEventListener('click', runLSTMPrediction);
        document.getElementById('runARIMA').addEventListener('click', runARIMAPrediction);
        document.getElementById('coinSelect').addEventListener('change', fetchMarketData);
        document.getElementById('timeframe').addEventListener('change', fetchMarketData);

        // Request notification permission on page load
        if ('Notification' in window) {
            Notification.requestPermission();
        }

        // ==================== Initialization ====================
        // Initialize LSTM model
        setupLSTM().catch(console.error);

        // Load initial data
        fetchMarketData();
    </script>
</body>

</html>